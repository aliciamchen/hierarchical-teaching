// webppl precalc.wppl --require webppl-json
// Calculate teacher feedback for experiment 2

var params = {
    alpha: 8,
    costWeight: 0,
    trueThetas: [0.01, 0.3, 0.7, 0.99], // true coin flip weight
    nExamples: 5,
    nTeachers: 2,
	teachers: ['A', 'B'],
    teacherKnowledgeLevels: ['full', 'partial'],
	learners: [0, 1],
    learnerHypers: [
		{a: 9, b: 1},
        {a: 1, b: 9}
	],
    firstExamples: [
        {a: 0, b: 5},
        {a: 1, b: 4},
        {a: 2, b: 3},
        {a: 3, b: 2},
        {a: 4, b: 1},
        {a: 5, b: 0},
    ],
    guessCost: 0.1
};

var round = function (num, precision) {
	Number.parseFloat(num.toFixed(precision));
  } ;


// discretizes a beta distribution over hypers (allows dp)
var Beta_disc = cache(function (hypers) {
	return Infer({method: 'enumerate'}, function() {
		var n = uniformDraw(_.range(0.01, 1, 0.01));
        var bta = Beta({ a: hypers.a == 0 ? 1 : hypers.a,
                        b: hypers.b == 0 ? 1 : hypers.b});
		factor(bta.score(n));
        return round(n, 2);
	})
});

var islandPrior = Categorical({vs: params.trueThetas})
var speakerPrior = Categorical({vs: params.learners})

// literal learner
var L0 = cache(function (examplesArray, learnerHypers) {
    return Infer ({ method: 'enumerate' }, function () {
        var theta = sample(islandPrior);
        var heads = reduce(function (example, acc) { return example.a + acc }, 0, examplesArray);
        var tails = reduce(function (example, acc) { return example.b + acc }, 0, examplesArray);
        var learnerDist = Beta({
            a: _.toNumber(learnerHypers.a + heads) == 0 ? 1 : _.toNumber(learnerHypers.a + heads),
            b: _.toNumber(learnerHypers.b + tails) == 0 ? 1 : _.toNumber(learnerHypers.b + tails)
        });
        observe(learnerDist, theta);
        return theta;
    })
});


// pragmatic speaker
var S1 = cache(function (theta, hypers, nExamples) {
    return Infer({ method: 'enumerate' }, function () {
      var nHeads = uniformDraw(_.range(0, nExamples + 1));
      var sampledExamples = {a: nHeads, b: nExamples - nHeads};
      factor(params.alpha * ((1 - params.costWeight) * L0([sampledExamples], hypers).score(theta)
                            - params.costWeight * nExamples));
      return {a: sampledExamples.a, b: sampledExamples.b};
    });
});

// uncertain pragmatic speaker
var S = cache(function (theta, nExamples) {
    return Mixture({
        dists: [S1(theta, params.learnerHypers[0], nExamples),
        S1(theta, params.learnerHypers[1], nExamples)],
        ps: [0.5, 0.5]
    })
});

// second example in sequential case
var S_second_ex_partial = cache(function (first_ex, theta, posterior, nExamples) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerClass = sample(posterior);
        var learnerHypers = params.learnerHypers[learnerClass];
        var nHeads = uniformDraw(_.range(0, nExamples + 1));
        var second_ex = { a: nHeads, b: nExamples - nHeads };

        factor(params.alpha * ((1 - params.costWeight) * L0([first_ex, second_ex], learnerHypers).score(theta)
			- params.costWeight * (second_ex.a + second_ex.b)));

        return second_ex;
    })
});

var S_second_ex_full = cache(function (first_ex, theta, hypers, nExamples) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerHypers = hypers;
        var nHeads = uniformDraw(_.range(0, nExamples + 1));
        var second_ex = { a: nHeads, b: nExamples - nHeads };

        factor(params.alpha * ((1 - params.costWeight) * L0([first_ex, second_ex], learnerHypers).score(theta)
			- params.costWeight * (second_ex.a + second_ex.b)));

        return second_ex;
    })
});

// after speaker sees learner's feedback after step 1, update speaker posterior over class membership
var updateSpeakerPosterior = cache(function (examples, guess) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerClass = sample(speakerPrior);
        var learnerHypers = params.learnerHypers[learnerClass];

        var learnerDist = L0(examples, learnerHypers);

        observe(learnerDist, guess)
        return learnerClass;
    })
});


var simulate = cache(function (teacherKnowledgeLevel, learnerClass, guess, firstExamples, theta, nExamples)
{
    if (teacherKnowledgeLevel === 'partial') {
        var posterior = guess == 'none' ? speakerPrior : updateSpeakerPosterior([firstExamples], guess);
        var examplesA = round(MAP(marginalize(S_second_ex_partial(firstExamples, theta, posterior, nExamples), 'a')).val, 0);
        return {a: examplesA, b: nExamples - examplesA};
    } else if (teacherKnowledgeLevel === 'full') {
        var examplesA = round(MAP(marginalize(S_second_ex_full(firstExamples, theta, params.learnerHypers[learnerClass], nExamples), 'a')).val, 0);
        return {a: examplesA, b: nExamples - examplesA};
    }
});

var output = _.flattenDeep(
    map ( function (theta) {
        return map(function(learnerClass) {
            return map(function(firstExamples) {
                return map ( function (guess) {
                  return map(function(teacherKnowledgeLevel) {
                      return {
                            learnerHypers: params.learnerHypers[learnerClass],
                          teacherKnowledgeLevel: teacherKnowledgeLevel,
                          theta: round(theta, 1),
                          firstExample: firstExamples,
                          guess: guess == 'none' ? guess : round(guess, 1),
                          secondExample: simulate(teacherKnowledgeLevel, learnerClass, guess, firstExamples, theta, params.nExamples)
                      }
                  }, params.teacherKnowledgeLevels)
                }, _.concat(params.trueThetas, 'none'))
            }, params.firstExamples)
        }, params.learners)
    }, params.trueThetas)
  );

json.write('../../experiments/learner/json/precalc_v4.json', output);
console.log('success! :)');
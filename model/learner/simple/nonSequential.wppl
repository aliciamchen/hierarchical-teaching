var feedback = true, noFeedback = false;

var params = {
    alpha: 4,
    costWeight: 10,
    trueTheta: .7, // true coin flip weight
    nTeachers: 2,
    nExamples: 10,
	maxExamples: 20,
    feedbackOptions: [feedback, noFeedback],
	teachers: ['A', 'B'],
    teacherExamples: {
		'A': {a: 4, b: 3},
		'B': {a: 3, b: 2}
	},
	learners: [1, 2],
    learnerHypers: {
        1: {a: 2, b: 8},
        2: {a: 8, b: 2}
    },
	inferOptions: { method: 'MCMC', samples: 4000 }
};

var round = function (num, precision) {
	Number.parseFloat(num.toFixed(precision));
  } ;


// discretizes a beta distribution over hypers (allows dp)
var Beta_disc = cache(function (hypers) {
	return Infer({method: 'enumerate'}, function() {
		var n = uniformDraw(_.range(0, 1, 0.01));
        var bta = Beta({ a: hypers.a == 0 ? 1 : hypers.a, 
                        b: hypers.b == 0 ? 1 : hypers.b});
		factor(bta.score(n));
        return round(n, 2);
	})
});

// literal learner
var L0 = cache(function (examples, hypers) {
	return Beta_disc({ a: hypers.a + examples.a, 
		b: hypers.b + examples.b });
});

// pragmatic speaker
var S1 = cache(function (theta, hypers) {
    return Infer({ method: 'enumerate' }, function () {
      var nExamples = uniformDraw(_.range(params.maxExamples + 1));
      var alpha = params.alpha, cw = params.costWeight;  
      var nHeads = uniformDraw(_.range(0, nExamples + 1));
      var sampledExamples = {a: nHeads, b: nExamples - nHeads};
      factor(alpha * (L0(sampledExamples, hypers).score(theta) - cw * nExamples));
      return {a: sampledExamples.a, b: sampledExamples.b};
    });
});

// pragmatic learner
var L1 = cache(function (examples, hypers) {
    return Infer({ method: 'enumerate' }, function () {
        var theta = sample(Beta_disc(hypers));
        observe(S1(theta, hypers), examples);
        return theta;
    });
});

// pragmatic learner decides whether or not to provide hypers
var L = cache(function (theta, hypers) {
    return Infer({ method: 'enumerate' }, function () {
        var cw = params.costWeight, nExamples = params.nExamples;
        var feedbackStatus = uniformDraw(params.feedbackOptions);
        var assumedHypers = feedbackStatus ? hypers : {a: 0, b: 0};
        var unknowingExamplesA = round(expectation(marginalize(S1(theta, assumedHypers), 'a')), 0);
        var knowingExamplesA = sample(S1(theta, hypers));
        var unknowingTeacherExamples = {a: unknowingExamplesA, b: nExamples - unknowingExamplesA}
        var unknowingTeacherExamples = {a: unknowingExamplesA, b: nExamples - unknowingExamplesA}
        factor(params.alpha * (L1(teacherExamples, hypers).score(theta) - cw * nExamples));
        return {feedbackProvided: feedbackStatus};
    });
});

// viz.auto(
L(params.trueTheta, params.learnerHypers[1]);
var params = {
    alpha: 10,
    costWeight: 0,
    trueTheta: .7, // true coin flip weight
    nExamples: 10,
    nHeads: 9, // temporary; provides number of heads given in example
    trueLearnerClass: 1,
    classHypers: {
        0: {a: 9, b: 1},
        1: {a: 9, b: 1}
    },
    classes: [0, 1]
};

// discretizes a beta distribution over hypers (allows dp)
var Beta_disc = cache(function (hypers) {
	return Infer({method: 'enumerate'}, function() {
		var n = uniformDraw(_.range(0, 1, 0.1));
        var bta = Beta({a : hypers.a, b : hypers.b});
		factor(bta.score(n));
		return n;
	})
});

// literal learner
var L0 = cache(function (nHeads, learnerHypers) {
    var a = learnerHypers.a, b = learnerHypers.b;
	return Beta_disc({ a: a + nHeads, b: b + params.nExamples - nHeads });
});

// pragmatic speaker
var S1 = cache(function (theta, learnerHypers) {
    return Infer({ method: 'enumerate'}, function () {
        var nExamples = params.nExamples, alpha = params.alpha, cw = params.costWeight;
        var nHeads = uniformDraw(_.range(0, nExamples + 1));
        factor(alpha * (L0(nHeads, learnerHypers).score(theta) - cw * nExamples));
        return nHeads;
    });
});

// uncertain pragmatic speaker
var S = cache(function(theta) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerClass = uniformDraw(params.classes);
        var learnerHypers = params.classHypers[learnerClass];
        return sample(S1(theta, learnerHypers));
    })
});

// pragmatic learner
var L1 = cache(function (nHeads, learnerHypers) {
    return Infer({ method: 'enumerate' }, function () {
        var theta = sample(Beta_disc(learnerHypers));
        observe(S(theta), nHeads);
        return theta;
    });
});

L1(params.nHeads, params.classHypers[params.trueLearnerClass]);

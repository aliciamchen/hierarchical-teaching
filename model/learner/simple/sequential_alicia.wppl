// this is basically the same as the 1d teacher model, just copying it here for funsies
var params = {
    type: 'point',
    participants: 193,
    alpha: 50,
    costWeight: 0.02,
    coinWeights: [0.3, 0.7], // true coin flip weight
    maxFlips: 70,
    scenarios: ['seqFeedback', 'nonSeqFull', 'nonSeqPartial', 'seqNoFeedback'],
    classrooms: ['A', 'B'],
    classHypers: {
        'A': { a: 1, b: 9 },
        'B': { a: 9, b: 1 }
    }
};

var islandPrior = Categorical({ vs: [0.3, 0.7] })
var teacherKnowledgePrior = Categorical({ vs: ['full', 'partial'] })

// discretizes a beta distribution over hypers (allows dp)

var round = function (num, precision) {
    Number.parseFloat(num.toFixed(precision));
};

var Beta_disc = cache(function (hypers) {
    return Infer({ method: 'enumerate' }, function () {
        var n = uniformDraw(_.range(0, 1, 0.01));
        var bta = Beta({
            a: hypers.a == 0 ? 1 : hypers.a,
            b: hypers.b == 0 ? 1 : hypers.b
        });
        factor(bta.score(n));
        return round(n, 2);
    })
});


//// Model

var classroomPrior = Categorical({ vs: params.classrooms })

// literal learner
var L0 = cache(function (examplesArray, learnerHypers) {
    var headsInExamples = reduce(function (example, acc) { return example.heads + acc }, 0, examplesArray)
    var totalExamples = reduce(function (example, acc) { return example.n + acc }, 0, examplesArray)
    return Beta_disc({
        a: _.toNumber(learnerHypers.a + headsInExamples),
        b: _.toNumber(learnerHypers.b + totalExamples - headsInExamples)
    });
});

// pragmatic speaker
var S1 = cache(function (theta, learnerHypers) {
    return Infer({ method: 'enumerate' }, function () {
        var nExamples = uniformDraw(_.range(1, params.maxFlips + 1));
        var nHeads = uniformDraw(_.range(0, nExamples + 1));
        var examples = { n: nExamples, heads: nHeads };
        factor(params.alpha * (L0([examples], learnerHypers).score(theta)
            - params.costWeight * examples.n));
        return examples;
        //return examples.heads / examples.n;
    });
});

// uncertain pragmatic speaker
var S = cache(function (theta, classroomOptions) {
    return Mixture({
        dists: [S1(theta, params.classHypers[classroomOptions[0]]),
        S1(theta, params.classHypers[classroomOptions[1]])],
        ps: [0.5, 0.5]
    })
});

// pragmatic learner compares teacher trustworthiness
var L = cache(function (hypers, examplesArray) {
    return Infer({ method: 'enumerate' }, function () {
        var cw = params.costWeight;

        var theta = sample(islandPrior);
        var teacherKnowledge = sample(teacherKnowledgePrior)

        var headsInExamples = reduce(function (example, acc) { return example.heads + acc }, 0, examplesArray)
        var totalExamples = reduce(function (example, acc) { return example.n + acc }, 0, examplesArray)

        var examples = {
            n: totalExamples,
            heads: headsInExamples
        }


        if (teacherKnowledge == 'full') {
            //           condition(s1Sample.a == examples.a)
            factor(params.alpha * (S1(theta, hypers).score(examples)));
            //         observe(S1(theta, hypers), examples)
        }
        else {
            //           condition(sSample.a == examples.a)
            factor(params.alpha * (S(theta, params.classrooms).score(examples)));
            //         observe(S(theta, params.classrooms), examples)
        }

        return { theta: theta, teacherKnowledge: teacherKnowledge };
    });
});


// viz.marginals(L({ a: 9, b: 1 }, [{ n: 10, heads: 5 }]))
var params = {
    directions: ['less', 'more'],
    nBins: 10,
    inferOptions: { method: 'MCMC', samples: 5000 },
    classrooms: {
        1: {}
    }
};

var xs = _.range(0, params.nBins + 1), ys = _.range(0, params.nBins + 1);

var prior = function (classroom) {

    var theta_1 = uniformDraw(_.range(1, params.nBins)), theta_2 = uniformDraw(_.range(1, params.nBins));
    var direction_1 = uniformDraw(params.directions), direction_2 = uniformDraw(params.directions);

    return {
        theta_1: theta_1,
        direction_1: direction_1,
        theta_2: theta_2,
        direction_2: direction_2
    }
}

var L0 = cache(function (example) {

    return Infer({ method: 'enumerate' }, function () {

        var prior = prior();

        var theta_1 = prior.theta_1, theta_2 = prior.theta_2
        var direction_1 = prior.direction_1, direction_2 = prior.direction_2

        var ps_x = direction_1 == 'less' ? map(function (i) { return i < theta_1 ? 1 : 0 }, xs) : map(function (i) { return i > theta_1 ? 1 : 0 }, xs)
        var ps_y = direction_2 == 'less' ? map(function (i) { return i < theta_2 ? 1 : 0 }, ys) : map(function (i) { return i > theta_2 ? 1 : 0 }, ys)

        observe(Categorical({ vs: xs, ps: ps_x }), example.x);
        observe(Categorical({ vs: ys, ps: ps_y }), example.y);

        return {
            theta_1: theta_1,
            direction_1: direction_1,
            theta_2: theta_2,
            direction_2: direction_2
        }
    })
});

var S1 = function (trueH) {
    return Infer(params.inferOptions,
        function () {
            var x = uniformDraw(xs), y = uniformDraw(ys)
            var example = { x: x, y: y }
            factor(L0(example).score(trueH))
            return example;
        }
    )
}




// after speaker sees learner's feedback after step 1, update speaker posterior over class membership
var updateSpeakerPosterior = function (data) {
    return Infer({ method: 'MCMC', samples: 5000 }, function () {
        var learnerClass = uniformDraw(params.classes);
        var learnerHypers = params.classHypers[learnerClass];

        mapData({ data: data }, function (example) {
            var learnerDist = L0(example, learnerHypers);
            var trueLearnerDist = L0(example, params.classHypers[params.trueLearnerClass])
            var learnerEstimate = sample(trueLearnerDist)

            observe(learnerDist, learnerEstimate)
        })

        return learnerClass;
    })
}

var model = function () {
    return Infer(params.inferOptions, function () {
        var learnerHypers = uniformDraw(params.classes);
        var step1example = sample(S1(params.trueH, params.classHypers[learnerHypers]))
        var speakerPosterior = updateSpeakerPosterior(step1example);
        var step2example = sample(S1(params.trueH, params.classHypers[sample(speakerPosterior)]));

        return {
            step1example: step1example,
            step2example: step2example
        }
    })
}

// var posterior = model()

// viz.auto(posterior)
// viz.marginals(posterior)
// viz.table(posterior)

// viz.table(L0({x: 5, y: 5}, params.classHypers[0]))
viz.table(S1(params.trueH, params.classHypers[0]))
// write `updatePosterior` function that takes in one turlte
// no cost weight here
// can return step 1 and step 2 number of heads
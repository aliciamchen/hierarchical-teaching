// webppl teacher_2d.wppl --require webppl-csv --random-seed 30

var params = {
    directions: ['less', 'greater'],
    participants: 50,
    alpha: 2,
    inferOptions: { method: 'enumerate' },
    priors: ['stem', 'cap'],
    trueConceptOptions: {
        stemThresholds: [2.5, 4.5, 6.5],
        capThresholds: [2.5, 4.5, 6.5],
        stemDirections: ['less', 'greater'],
        capDirections: ['less', 'greater']
    },
    scenarios: ['seqFeedback', 'nonSeqFull', 'nonSeqPartial', 'seqNoFeedback']
};

var f = csv.open('./output/' + 'v1' + '_alpha' + params.alpha + '_' + params.participants + '.csv')
csv.writeLine('subject_id,alpha,block_type,trial_num,trueStemThresh,trueCapThresh,trueStemDir,trueCapDir,prior,stemResponse,capResponse', f)
// TODO: add exact feedback the teacher gave

var makeTrials = function () {
    return _.flattenDeep(
        mapN(function (participant) {
            return map(function (scenario) {
                return map(function (stemThreshold) {
                    return map(function(stemDirection) {
                        return map(function(capThreshold) {
                            return map(function(capDirection) {
                                return map(function (classroom) {
                                    return {
                                        participantID: participant,
                                        scenario: scenario,
                                        trueH: {
                                            stemThreshold: stemThreshold,
                                            capThreshold: capThreshold,
                                            stemDirection: stemDirection,
                                            capDirection: capDirection,
                                        },
                                        prior: classroom
                                    }
                                }, params.priors)
                            }, params.trueConceptOptions.capDirections)
                        }, params.trueConceptOptions.capThresholds)
                    }, params.trueConceptOptions.stemDirections)
                }, params.trueConceptOptions.stemThresholds)
            }, params.scenarios)
        }, params.participants)
    )
}


var xs = _.range(1, 9), ys = _.range(1, 9);

var classroomPrior = Categorical({vs: params.priors})
// `prior` is either 'stem' or 'cap'
// this function just takes the prior and outputs the stuff in the true H that learner knows
var findHypers = function (trueH, prior) {
    if (prior === 'stem') {
        return {
            stemThreshold: trueH.stemThreshold,
            stemDirection: trueH.stemDirection
        }
    } else if (prior === 'cap') {
        return {
            capThreshold: trueH.capThreshold,
            capDirection: trueH.capDirection
        }
    }
}

var prior = function (hypers) {

    var stemThreshold = typeof hypers.stemThreshold == "undefined" ? uniformDraw(_.range(1.5, 8, 1)) : hypers.stemThreshold;
    var capThreshold = typeof hypers.capThreshold == "undefined" ? uniformDraw(_.range(1.5, 8, 1)) : hypers.capThreshold;

    var stemDirection = typeof hypers.stemDirection == "undefined" ? uniformDraw(params.directions) : hypers.stemDirection;
    var capDirection = typeof hypers.capDirection == "undefined" ? uniformDraw(params.directions) : hypers.capDirection;

    return {
        stemThreshold: stemThreshold,
        stemDirection: stemDirection,
        capThreshold: capThreshold,
        capDirection: capDirection
    }
}

var L0 = cache(function (example, hypers) {
    // console.log(example)
    // console.log(hypers)
    return Infer({ method: 'enumerate' }, function () {

        var prior = prior(hypers);

        var stemThreshold = prior.stemThreshold, capThreshold = prior.capThreshold
        var stemDirection = prior.stemDirection, capDirection = prior.capDirection

        var ps_x = stemDirection == 'less' ? map(function (i) { return i < stemThreshold ? 1 : 0 }, xs) : map(function (i) { return i > stemThreshold ? 1 : 0 }, xs)
        var ps_y = capDirection == 'less' ? map(function (i) { return i < capThreshold ? 1 : 0 }, ys) : map(function (i) { return i > capThreshold ? 1 : 0 }, ys)

        // console.log(ps_x)
        // console.log(xs)
        // console.log(example.stem)
        // console.log(ps_y)
        // console.log(xs)
        // console.log(ps_x)
        // console.log(categorical({ vs: xs, ps: ps_x }))
        observe(Categorical({ vs: xs, ps: ps_x }), example.stem);
        // console.log('here')
        observe(Categorical({ vs: ys, ps: ps_y }), example.cap);

        return {
            stemThreshold: stemThreshold,
            stemDirection: stemDirection,
            capThreshold: capThreshold,
            capDirection: capDirection
        }
    })
});



var S1 = cache(function (trueH, hypers) {
    return Infer({method: 'enumerate'},
        function () {
            console.log(trueH)

            var ps_x = trueH.stemDirection == 'less' ? map(function (i) { return i < trueH.stemThreshold ? 1 : 0 }, xs) : map(function (i) { return i > trueH.stemThreshold ? 1 : 0 }, xs)
            var ps_y = trueH.capDirection == 'less' ? map(function (i) { return i < trueH.capThreshold ? 1 : 0 }, ys) : map(function (i) { return i > trueH.capThreshold ? 1 : 0 }, ys)

            console.log(ps_x)
            console.log(xs)
            console.log(ps_y)
            console.log(ys)
            console.log(categorical({vs: [1, 2, 3, 4, 5, 6, 7, 8], ps: [0.5, 0.5, 0, 0, 0.5, 0, 0, 0]}))
            var x = categorical({vs: xs, ps: ps_x})
            var y = categorical({vs: ys, ps: ps_y})
            var example = { stem: x, cap: y }

            console.log(example)
            factor(params.alpha * L0(example, hypers).score(trueH))

            return example;
        }
    )
})

// one-shot partial-knowledge
var S = cache(function(trueH) {
    return Infer({method: 'enumerate'}, function() {
        var learnerHypers = findHypers(trueH, sample(classroomPrior))
        return sample(S1(trueH, learnerHypers))
    })
});

// second example in sequential case
var S_second_ex = function(first_ex, trueH, posterior) {
    return Infer(params.inferOptions, function() {
        var classroom = sample(posterior);
        var learnerHypers = findHypers(trueH, classroom)

        var ps_x = trueH.stemDirection == 'less' ? map(function (i) { return i < trueH.stemThreshold ? 1 : 0 }, xs) : map(function (i) { return i > trueH.stemThreshold ? 1 : 0 }, xs)
        var ps_y = trueH.capDirection == 'less' ? map(function (i) { return i < trueH.capThreshold ? 1 : 0 }, ys) : map(function (i) { return i > trueH.capThreshold ? 1 : 0 }, ys)

        var second_x = categorical({vs: xs, ps: ps_x})
        var second_y = categorical({vs: ys, ps: ps_y})

        var second_ex = {stem: second_x, cap: second_y};

        factor(params.alpha * L0(first_ex, learnerHypers).score(trueH))
        factor(params.alpha * L0(second_ex, learnerHypers).score(trueH))

        return second_ex;
    })
}

// after speaker sees learner's feedback after step 1, update speaker posterior over class membership
var updateSpeakerPosterior = function (example, trueH, learnerFeedback) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerClass = uniformDraw(params.priors);
        var learnerHypers = findHypers(trueH, learnerClass);

        var learnerDist = L0(example, learnerHypers);
        // var trueLearnerDist = L0(example, params.classroomPriors[params.trueLearnerClass]);
        var learnerEstimate = sample(learnerDist)
        // change to MAP later?

        factor(learnerEstimate === learnerFeedback ? 100 : 0) // comment out for no-feedback case
        return learnerClass;
        })

    }

var sequential = cache(function (scenario, trueH, classroom) {
    return Infer({ method: 'enumerate' }, function () {
        var step1example = sample(S(trueH, params.priors))
        console.log(step1example)
        var learnerFeedback = sample(L0(step1example, findHypers(trueH, classroom)))
        var speakerPosterior = (scenario === 'seqFeedback' ?
            updateSpeakerPosterior(step1example, trueH, learnerFeedback) :
            classroomPrior)
        var step2example = sample(S_second_ex(step1example, trueH, speakerPosterior));
        return {
            step1example: step1example,
            step2example: step2example
        }
    })
})

var simulate = cache(function (scenario, trueH, classroom) {
    // console.log(trueH)
    console.log(scenario)
    if (scenario === 'nonSeqFull') {
        return S1(trueH, findHypers(trueH, classroom))
    } else if (scenario === 'nonSeqPartial') {
        return S(trueH)
    } else {
        return sequential(scenario, trueH, classroom)
    }
})


// viz.table(S1(params.trueH, params.classroomPriors[0]))
//// Simulate

var trials = makeTrials();
// console.log(trials);


map(function (trial) {
    console.log('participant ' + trial.participantID)

    var response = sample(simulate(trial.scenario, trial.trueH, trial.classroom))

    if (trial.scenario === 'nonSeqFull' || trial.scenario === 'nonSeqPartial') {

        csv.writeLine([
            trial.participantID,
            params.alpha,
            trial.scenario,
            0,
            trial.trueH.stemThreshold,
            trial.trueH.capThreshold,
            trial.trueH.stemDirection,
            trial.trueH.capDirection,
            trial.prior,
            response.stem,
            response.cap
        ].join(','), f)

    } else {

        csv.writeLine([
            trial.participantID,
            params.alpha,
            trial.scenario,
            0,
            trial.trueH.stemThreshold,
            trial.trueH.capThreshold,
            trial.trueH.stemDirection,
            trial.trueH.capDirection,
            trial.prior,
            response.step1example.stem,
            response.step1example.cap
        ].join(','), f)

        csv.writeLine([
            trial.participantID,
            params.alpha,
            params.costWeight,
            trial.scenario,
            1,
            trial.coinWeight,
            trial.prior,
            response.step2example.stem,
            response.step2example.cap
        ].join(','), f)
    }
}, trials)

csv.close(f);

var params = {
    alpha: 4,
    costWeight: 0,
    trueTheta: .7, // true coin flip weight
    nExamples: 10,
    classes: [0, 1],
    trueLearnerClass: 1,
    classHypers: {
        0: { a: 2, b: 8 },
        1: { a: 8, b: 2 }
    }
};

var L0Mean = function(examples, learnerPrior) {
    return (learnerPrior.a + examples.heads) / (learnerPrior.a + learnerPrior.b + examples.n)
}
// var L0Median
// var L0Mode

// literal learner
var L0 = function (examples, learnerPrior) {
    return Beta({ a: _.toNumber(learnerPrior.a + examples.heads), b: _.toNumber(learnerPrior.b + examples.n - examples.heads) });
};
// console.log(L0({n: 20, heads: 0}, {a: 1, b: 1}))

// pragmatic speaker
var S1 = function (theta, learnerPrior) {
    return Infer({ method: 'enumerate' }, function () {
        var nExamples = params.nExamples;
        var nHeads = uniformDraw(_.range(0, nExamples + 1));
        var examples = { n: nExamples, heads: nHeads };
        factor(params.alpha * (L0(examples, learnerPrior).score(theta) - params.costWeight * examples.n));
        return examples;
    });
};


// pragmatic learner (not used)
var L1 = function (examples, learnerPrior) {
    return Infer({ method: 'enumerate' }, function () {
        var theta = Beta({ a: learnerPrior.a, b: learnerPrior.b });
        observe(S1(theta, learnerPrior), examples);
        return theta;
    })
}

// pragmatic speaker, marginalizing over possible classrooms
var S = function (theta) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerClass = uniformDraw(params.classes);
        var learnerPrior = params.classHypers[learnerClass];

        return sample(S1(theta, learnerPrior))
    })
}


// rename learnerPrior to learnerHypers or something
var updateLearnerPosterior = function (data) {
    return Infer({ method: 'MCMC', samples: 5000}, function () {
        var learnerClass = uniformDraw(params.classes);
        var learnerPrior = params.classHypers[learnerClass];
//         var learnerEstimate = L0Mean(data, learnerPrior);
//         var trueLearnerEstimate = L0Mean(data, params.classHypers[params.trueLearnerClass]);
      var learnerDist = L0(data, learnerPrior);
      var trueLearnerDist = L0(data, params.classHypers[params.trueLearnerClass])
      var learnerEstimate = sample(trueLearnerDist)
//         condition(learnerEstimate === trueLearnerEstimate);
      observe(learnerDist, learnerEstimate)
        return learnerClass;
    })
}

var model = function () {
    return Infer({ method: 'enumerate' }, function () {
//         var learnerPrior = uniformDraw(params.classes);
      var firstExamples = sample(S(params.trueTheta))
//         var firstExamples = sample(S1(params.trueTheta, params.classHypers[learnerPrior]));
        var learnerPosterior = updateLearnerPosterior(firstExamples);
//       console.log(learnerPosterior)
        var secondExamples = sample(S1(params.trueTheta, params.classHypers[sample(learnerPosterior)]));
//       factor(L0(secondExamples, params.classHypers[sample(learnerPosterior)]).score(params.trueTheta))
        return {
            step1: firstExamples.heads,
            step2: secondExamples.heads,
          classroom: sample(learnerPosterior)
        }
    })
}

var posterior = model()

viz.auto(posterior)
viz.marginals(posterior)
// viz.table(posterior)
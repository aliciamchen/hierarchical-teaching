var params = {
    alpha: 4,
    costWeight: 0,
    trueTheta: .6, // true coin flip weight
    nExamples: 20,
    classes: [0, 1],
    trueLearnerClass: 0, // true learner class
    classHypers: {
        0: {a: 3, b: 10},
        1: {a: 10, b: 3}
    }
};

// literal learner
var L0 = function (examples, learnerPrior) {
    return Beta({ a: _.toNumber(learnerPrior.a + examples.heads), b: _.toNumber(learnerPrior.b + examples.n - examples.heads) });
};


// pragmatic speaker
var S1_first = function (theta) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerClass = uniformDraw(params.classes);
        var learnerPrior = params.classHypers[learnerClass];

        var nExamples = params.nExamples;
        var nHeads = uniformDraw(_.range(0, nExamples + 1));
        var examples = { n: nExamples, heads: nHeads };
        factor(params.alpha * (L0(examples, learnerPrior).score(theta) - params.costWeight * examples.n));
        return examples;
    });
};


var S1_second = function (theta, learnerPrior) {
    return Infer({ method: 'enumerate' }, function () {
        var nExamples = params.nExamples;
        var nHeads = uniformDraw(_.range(0, nExamples + 1));
        var examples = { n: nExamples, heads: nHeads };
        factor(params.alpha * (L0(examples, learnerPrior).score(theta) - params.costWeight * examples.n));
        return examples;
    });
};


//////
var firstUtt = S1_first(params.trueTheta, uncertain learner prior)
var posterior = updatePosterior(data=firstUtt)
var secondUtt = S1_second(params.trueTheta, marginalize(posterior, 'class'))

// plot path dependency

/// I think this is how you do it, don't optimize for uniform good stuff

/////

// perfect teacher:
// teacher knows likelihood of learner inferring trueTheta given whatever examples the teacher selects
var updatePosterior = function () {
    return Infer({ method: 'MCMC', samples: 50000, burn: 1000 }, function () {
        // sample object speaker selected from S1

        var learnerClass = uniformDraw(params.classes);
        var learnerPrior = params.classHypers[learnerClass];

        var speakerExamples = sample(S1(params.trueTheta, learnerPrior));

        factor(L0(speakerExamples, params.classHypers[params.trueLearnerClass]).score(params.trueTheta));
        return { class: learnerClass, examples: speakerExamples }
    });
};

// first stage is non sequential partial but you update posterior
// sample from S1
// what is the posterior given response from S1?
// and then sample from updated posterior dist

var results = updatePosterior()


viz.table(marginalize(results, 'examples'))
viz.auto(marginalize(results, 'class'))
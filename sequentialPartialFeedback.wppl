var params = {
    alpha: 4,
    costWeight: 0,
    trueTheta: .7, // true coin flip weight
    nExamples: 20,
    classes: [0, 1],
    trueLearnerClass: 0,
    classHypers: {
        0: { a: 30, b: 30 },
        1: { a: 1, b: 1 }
    }
};

var L0Mean = function(examples, learnerPrior) {
    return (learnerPrior.a + examples.heads) / (learnerPrior.a + learnerPrior.b + examples.n)
}
// var L0Median
// var L0Mode

// literal learner
var L0 = function (examples, learnerPrior) {
    return Beta({ a: _.toNumber(learnerPrior.a + examples.heads), b: _.toNumber(learnerPrior.b + examples.n - examples.heads) });
};
// console.log(L0({n: 20, heads: 0}, {a: 1, b: 1}))

// pragmatic speaker
var S1 = function (theta, learnerPrior) {
    return Infer({ method: 'enumerate' }, function () {
        var nExamples = params.nExamples;
        var nHeads = uniformDraw(_.range(0, nExamples + 1));
        var examples = { n: nExamples, heads: nHeads };
        factor(params.alpha * (L0(examples, learnerPrior).score(theta) - params.costWeight * examples.n));
        return examples;
    });
};


// pragmatic learner (not used)
var L1 = function (examples, learnerPrior) {
    return Infer({ method: 'enumerate' }, function () {
        var theta = Beta({ a: learnerPrior.a, b: learnerPrior.b });
        observe(S1(theta, learnerPrior), examples);
        return theta;
    })
}

// pragmatic speaker, marginalizing over possible classrooms
var S = function (theta) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerClass = uniformDraw(params.classes);
        var learnerPrior = params.classHypers[learnerClass];

        return sample(S1(theta, learnerPrior))
    })
}


// rename learnerPrior to learnerHypers or something
var updateLearnerPosterior = function (data) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerClass = uniformDraw(params.classes);
        var learnerPrior = params.classHypers[learnerClass];
        var learnerEstimate = L0Mean(data, learnerPrior);
        var trueLearnerEstimate = L0Mean(data, params.classHypers[params.trueLearnerClass]);

//         console.log(learnerEstimate)
//         console.log(trueLearnerEstimate)
        factor(learnerEstimate === trueLearnerEstimate ? 1 : 0);
        return learnerClass;
    })
}

var model = function () {
    return Infer({ method: 'enumerate' }, function () {
        var learnerPrior = uniformDraw(params.classes);
        var firstExamples = sample(S1(params.trueTheta, params.classHypers[learnerPrior]));
        var learnerPosterior = updateLearnerPosterior(firstExamples);
//       console.log(learnerPosterior)
        var secondExamples = sample(S1(params.trueTheta, params.classHypers[sample(learnerPosterior)]));
        return {
            step1: firstExamples,
            step2: secondExamples,
        }
    })
}

model()
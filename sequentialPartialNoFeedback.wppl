var params = {
    alpha: 4,
    costWeight: 0,
    trueTheta: .7, // true coin flip weight
    nExamples: 20,
    classes: [0, 1],
    trueLearnerClass: 0,
    classHypers: {
        0: {a: 30, b: 30},
        1: {a: 1, b: 1}
    }
};

// literal learner
var L0 = function (examples, learnerPrior) {
    return Beta({ a: _.toNumber(learnerPrior.a + examples.heads), b: _.toNumber(learnerPrior.b + examples.n - examples.heads) });
};

// pragmatic speaker
var S1 = function (theta, learnerPrior) {
    return Infer({ method: 'enumerate' }, function () {
        var nExamples = params.nExamples;
        var nHeads = uniformDraw(_.range(0, nExamples + 1));
        var examples = { n: nExamples, heads: nHeads };
        factor(params.alpha * (L0(examples, learnerPrior).score(theta) - params.costWeight * examples.n));
        return examples;
    });
};

// pragmatic learner (not used)
var L1 = function (examples, learnerPrior) {
    return Infer({method: 'enumerate'}, function () {
        var theta = Beta({a: learnerPrior.a, b: learnerPrior.b});
        observe(S1(theta, learnerPrior), examples);
        return theta;
    })
}

// pragmatic speaker, marginalizing over possible classrooms
var S = function(theta) {
    return Infer({ method: 'enumerate' }, function () {
        var learnerClass = uniformDraw(params.classes);
        var learnerPrior = params.classHypers[learnerClass];

        return sample(S1(theta, learnerPrior))
    })
}

var updateSpeakerPosterior = function(data) {
    return Infer({method: 'enumerate'}, function() {
        var learnerClass = uniformDraw(params.classes);
        var
    })
}

var model = function() {
    return Infer({method: 'enumerate'}, function() {
        var learnerPrior = params.classHypers[uniformDraw(params.classes)];
        var firstExamples = sample(S1(params.trueTheta, learnerPrior));



    })
}

// S1(params.trueTheta)
S(params.trueTheta);